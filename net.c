#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define LINE_LEN 256
//accessing procfs, not a "real" file on the disk, only exists in the memory, dynamically generated by the kernel using specific instructions, and is a VFS (Virtual File System) 
#define TCP_PATH "/proc/net/tcp"

struct Connection 
{   
    char local_ip[64];
    char remote_ip[64];
    char local_hex[50];
    char remote_hex[50];
    char state_hex[5];
    unsigned int local_ip_int,remote_ip_int;
    int state_int,local_port,remote_port;
    struct Connection *next;
    };

//swaps little endian to big endian, (1.0.0.127 to 127.0.0.1) but in hex, returns unsigned int.
unsigned int swap_endian(char *val1){
    //turning the string into an unsigned long/int, stopping at '\0'
    unsigned int val = (unsigned int)strtoul(val1,NULL,16);
    
    //the name assignment is post swap, to make the return easier to understand.
    unsigned int left_most = (val & 0x000000FF) << 24;
    unsigned int right_most = (val & 0xFF000000) >> 24;
    unsigned int mid_left = (val & 0x0000FF00) << 8; 
    unsigned int mid_right = (val & 0x00FF0000) >> 8;
    
    // returned in order!
    return left_most | mid_left | mid_right | right_most; 
    }

//function to translate state from a value to a string
const char* state_translation(unsigned int state_val){
    switch(state_val){
	case 0x01:
	    return "ESTABLISHED";
	case 0x02:
	    return "SYN_SENT";
	case 0x03:
	    return "SYN_RECV";
	case 0x06:
	    return "TIME_WAIT";
	case 0x08:
	    return "CLOSE_WAIT";
	case 0x0A:
	    return "LISTENING";
	default:
	    return "UNKNOWN";
	}
    }

//main function
int main(int argc, char* argv[]){
    
    if(argc != 2){
	    printf("Fix your arguments\n");
	    return 1;
	}
    if(argv[1]==NULL){
	    printf("Add a valid argument!\n-a (all connection states)\n-t (ESTABLISHED connection states)\n-l (LISTENING connection states)");
	}
    
    int mode = 0;
    if(strcmp(argv[1],"-a")==0){
	mode = 1;
    }
    else if(strcmp(argv[1],"-t")==0){
	mode = 2;
    }
    else if(strcmp(argv[1],"-l")==0){
	mode = 3;
    }
    else{
	fprintf(stderr,"Invalid argument\n");
	return -1;
    }
    
    FILE *infile;
    infile = fopen(TCP_PATH, "r");
    char line[LINE_LEN];

    if(infile == NULL){
	    printf("Error reading /proc/net/tcp\n");
	    fclose(infile);
	    return 1;
	}

    if(fgets(line,LINE_LEN,infile)==NULL){
	    printf("Error reading header\n");
	    fclose(infile);
	    return 1;
	}
    
    printf("Successfully retrieved /proc/net/tcp! Displaying connections...\n");
    
    printf("%-25s %-25s %-12s\n","Local Address:PORT","Remote Address:PORT","STATE");
    
    struct Connection *head = NULL;
    struct Connection *tail = NULL;

    while(fgets(line,LINE_LEN,infile) != NULL){
/*
going into the heap to find the address of exactly the amount that malloc is asking for.
malloc returns a void* pointer, the cast type tells the compiler to treat the mem address as the
start of a Connection structure, without the cast, the compiler wouldn't know how to navigate
the memory.
 */
	struct Connection *new_node = (struct Connection*)malloc(sizeof(struct Connection));	
	if(new_node == NULL){
	    fprintf(stderr,"Mem allocation failed\n");
	    break;
	    }
	
	if(new_node == NULL){
		fprintf(stderr, "Mem allocation failed.\n");
		break;
	    }

	if(head == NULL){
	    head = new_node;
	    }
	else{
	    tail->next=new_node;
	    }
	tail = new_node;
	//no hex to decimal conversion function needed because the format specifier %d is taking the hex base16 and converting it to base10 or decimal
	// %[^:] takes all input into a string until it hits the column :
	if(sscanf(line,"%*d: %[^:]:%x %[^:]:%x %s %*x:%*x %*x:%*x %*x %*d %*d %*d",new_node->local_hex,&new_node->local_port,new_node->remote_hex,&new_node->remote_port,new_node->state_hex)){
	    new_node->local_ip_int = swap_endian(new_node->local_hex);
	    new_node->remote_ip_int = swap_endian(new_node->remote_hex);
	    new_node->state_int = (unsigned int)strtoul(new_node->state_hex,NULL,16);
	    sprintf(new_node->local_ip,"%d.%d.%d.%d:%d",(new_node->local_ip_int >> 24)&0xFF,(new_node->local_ip_int >> 16)&0xFF,(new_node->local_ip_int >> 8)&0xFF,new_node->local_ip_int&0xFF,new_node->local_port);
	    sprintf(new_node->remote_ip,"%d.%d.%d.%d:%d",(new_node->remote_ip_int >> 24)&0xFF,(new_node->remote_ip_int >> 16)&0xFF,(new_node->remote_ip_int >> 8)&0xFF,(new_node->remote_ip_int)&0xFF,new_node->remote_port);
	}
    }
    

    struct Connection *curr;
    for(curr=head; curr!=NULL; curr=curr->next){
	if(mode == 1){
	    printf("%-25s %-25s %-12s\n",curr->local_ip,curr->remote_ip,state_translation(curr->state_int));
		}
	else if(mode == 2 && curr->state_int == 0x01){
	    printf("%-25s %-25s %-12s\n",curr->local_ip,curr->remote_ip,state_translation(curr->state_int));
		
	    }
	else if(mode == 3 && curr->state_int == 0x0A){
	    printf("%-25s %-25s %-12s\n",curr->local_ip,curr->remote_ip,state_translation(curr->state_int));
		}
	    }


    fclose(infile);
    struct Connection *temp;
    while(head != NULL){
	temp = head;
	head = head->next;
	free(temp);

	}
    return 0;
}

